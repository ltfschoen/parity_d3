<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    div.chart {
      font-family: sans-serif;
      font-size: 0.7em;
    }

    div.category {
      margin-left: 20px;
      line-height: 1em;
      margin-bottom: 15px;
    }

    div.category-text-value {
      margin-left: 40px;
    }

    span.label-wrapper {
      width: 100px;
      display: inline-block;
    }

    span.sub-label-wrapper {
      width: 100px;
      display: inline-block;
    }

    div.label {
      margin-left: 40px;
    }

    div.sub-label {
      margin-left: 60px;
    }

    div.bar {
      margin-left: 20px;
      background-color: DarkRed;
      border-radius: 20px;
      color: white;
      padding-right: 1em;
      text-align: right;
      display: inline-block;
    }

    div.amount-bar {
      margin-left: 20px;
      background-color: Gold;
      border-radius: 20px;
      color: white;
      padding-right: 1em;
      text-align: right;
      display: inline-block;
    }

    div.label-text-value {
      margin-left: 20px;
      /*padding-right: 10em;*/
      display: inline-block;
    }

    span.spacer {
      width: 100%;
      display: inline-block;
    }
  </style>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://parity.io/javascript_advert.js"></script>
  <script>window.d3 || document.write('<script src="js/d3.v4.min.js">\x3C/script>')</script>
  <script>window.job || document.write('<script src="js/javascript_advert.js">\x3C/script>')</script>
  <script src="./node_modules/moment/min/moment.min.js"></script>
  <script>
    let barLabels = ["profile"];
    let barAmountLabels = ["amount"];
    let unfitableLabels = ["date", "workweek", "from", "to"];

    function isBarLabel(propertyName, parentName) {
      return (barLabels.indexOf(propertyName) != -1 || barLabels.indexOf(parentName) != -1);
    }

    function isBarAmountLabel(propertyName) {
      return barAmountLabels.indexOf(propertyName) != -1;
    }

    function isUnfitableLabel(propertyName, parentName) {
      return (unfitableLabels.indexOf(propertyName) != -1 || unfitableLabels.indexOf(parentName) != -1);;
    }

    function isObject(obj) {
      return obj && (typeof obj  === "object");
    }

    function isArray(obj) {
      return isObject(obj) && (obj instanceof Array);
    }

    function getNewLineForLevel(level, data) {
      return level.selectAll(".div.line")
        .data(data)
        .enter()
        .append("div")
        .attr("class", "line")
    }

    function getCategoryForLine(line, keyIndex) {
      return line.append("div")
        .attr("class", "category")
        .text(function (d) {
          return Object.keys(d)[keyIndex]
        })
    }

    function getLabelForCategory(category, categoryName) {
      return category.append("div")
        .attr("class", "label")
    }

    function getSublabelOfLabelForCategory(subcategory, category, categoryName) {
      return subcategory.append("div")
        .attr("class", "sub-label")
    }

    function renderValueForCategory(category, categoryName) {
      category.append("span")
        .attr("class", "spacer")

      return category.append("div")
        .attr("class", "category-text-value")
        .text(function (d) {
          return d[categoryName]
        })
    }

    function renderSublabelValueForLabel(propertyName, data, label, categoryName, keyIndex) {
      let propertyValue = data[0][categoryName][propertyName];

      label.append("span")
        .attr("class", "spacer")
      label.append("span")
        .attr("class", "label-wrapper")
        .text(function (d) {
          return Object.keys(d[categoryName])[keyIndex];
        })

      if (isObject(propertyValue) && !isArray(propertyValue)) {
        return
      }
      return processRender(label, propertyValue, propertyName, categoryName);
    }

    function renderSubSublabelValueForLabel(propertyName, subPropertyName, data, subLabel, label, categoryName, keyIndex, subKeyIndex) {
      let subPropertyValue = data[0][categoryName][propertyName][subPropertyName];

      subLabel.append("span")
        .attr("class", "spacer")
      subLabel.append("span")
        .attr("class", "sub-label-wrapper")
        .text(function (d) {
          return Object.keys(d[categoryName][propertyName])[subKeyIndex];
        })

      return processRender(subLabel, subPropertyValue, subPropertyName, propertyName);
    }

    function processRender(label, propertyValue, propertyName, parentName) {
      return label.append("div")
        .attr("class", function (d) {
          if (typeof propertyValue === "number" && isBarLabel(propertyName, parentName) ) {
            return "bar";
          } else if (typeof propertyValue === "number" && isBarAmountLabel(propertyName)) {
            return "amount-bar"
          } else if (typeof propertyValue === "number") {
            return "label-text-value";
          } else if (typeof propertyValue === "string") {
            return "label-text-value";
          } else if (typeof propertyValue === "object") {
            return "label-text-value";
          } else if (typeof propertyValue === "boolean") {
            return "label-text-value";
          }
        })
        .style("width", function (d) {
          if (typeof propertyValue === "number" && isUnfitableLabel(propertyName, parentName)) {
            return "";
          } else if (typeof propertyValue === "number" && isBarLabel(propertyName, parentName)) {
            return propertyValue + "px";
          } else if (typeof propertyValue === "number" && isBarAmountLabel(propertyName)) {
            return propertyValue / 100 + "px";
          } else {
            return "";
          }

        })
        .text(function (d) {
          if (typeof propertyValue === "number" && propertyName.indexOf("date") == -1) {
            return Math.round(propertyValue);
          } else if (typeof propertyValue === "number" && propertyName.indexOf("date") != -1) {
            return moment(new Date(propertyValue)).calendar();
          } else if (typeof propertyValue ===  "string") {
            return propertyValue;
          } else if (typeof propertyValue ===  "object") {
            return propertyValue;
          } else if (typeof propertyValue ===  "boolean") {
            return propertyValue;
          }
        })
    }

    function renderLevelsForCategory(data, categoryKey, categoryLabel, category, categoryName) {
      let i1 = 0;
      for (let k1 in categoryKey) {
        renderSublabelValueForLabel(k1, data, categoryLabel, categoryName, i1);
        if (isObject(categoryKey[k1]) && !isArray(categoryKey[k1])) {
          let i2 = 0;
          for (let k2 in categoryKey[k1]) {
            let sublabel = getSublabelOfLabelForCategory(categoryLabel, category, categoryName);
            renderSubSublabelValueForLabel(k1, k2, data, sublabel, categoryLabel, categoryName, i1, i2);
            i2++;
          }
        }
        i1++;
      }
    }

    function draw(data) {
      "use strict";

      let chart = d3.select("body")
        .append("div")
        .attr("class", "chart")

      let headlineLine = getNewLineForLevel(chart, data);
      let headlineCategory = getCategoryForLine(headlineLine, 0);
      let headlineCategoryName = headlineCategory._groups[0][0].innerText;
      renderValueForCategory(headlineCategory, headlineCategoryName);

      let essentialsLine = getNewLineForLevel(chart, data);
      let essentialsCategory = getCategoryForLine(essentialsLine, 1);
      let essentialsCategoryName = essentialsCategory._groups[0][0].innerText;
      let essentialsLabel = getLabelForCategory(essentialsCategory, essentialsCategoryName);
      let essentialsKey = data[0][essentialsCategoryName];
      renderLevelsForCategory(data, essentialsKey, essentialsLabel, essentialsCategory, essentialsCategoryName);

      let methodologyLine = getNewLineForLevel(chart, data);
      let methodologyCategory = getCategoryForLine(methodologyLine, 2);
      let methodologyCategoryName = methodologyCategory._groups[0][0].innerText;
      let methodologyLabel = getLabelForCategory(methodologyCategory, methodologyCategoryName);
      let methodologyKey = data[0][methodologyCategoryName];
      renderLevelsForCategory(data, methodologyKey, methodologyLabel, methodologyCategory, methodologyCategoryName);

      let specsLine = getNewLineForLevel(chart, data);
      let specsCategory = getCategoryForLine(specsLine, 3);
      let specsCategoryName = specsCategory._groups[0][0].innerText;
      let specsLabel = getLabelForCategory(specsCategory, specsCategoryName);
      let specsKey = data[0][specsCategoryName];
      renderLevelsForCategory(data, specsKey, specsLabel, specsCategory, specsCategoryName);

      let profileLine = getNewLineForLevel(chart, data);
      let profileCategory = getCategoryForLine(profileLine, 4);
      let profileCategoryName = profileCategory._groups[0][0].innerText;
      let profileLabel = getLabelForCategory(profileCategory, profileCategoryName);
      renderSublabelValueForLabel("newfeatures", data, profileLabel, profileCategoryName, 0);
    }
  </script>
</head>
<body>

</body>
<script>
  document.addEventListener("DOMContentLoaded", function (event) {
    let jsonOutput = [{}];

    function iterate(obj) {
      for (let property in obj) {
        if (obj.hasOwnProperty(property)) {
          jsonOutput[0][property] = obj[property];
        }
      }
    }

    iterate(job);
    draw(jsonOutput);
  });
</script>
</html>